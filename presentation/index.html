<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>TDD presentation</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/custom.css">


		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
  <aside class="notes">
    1. The basics of automated unit testing and assertions
  </aside>


  <h1>Test Driven Development</h1>
  <h6>(With javascript &#9786;)</h6>
</section>
				<section>
  <img src="../assets/johansenBook.png">
</section>
				<!-- Veritcal Nexted Slides-->
<section>
  <section>
    <aside class="notes">
      How do we make sure this function is working the way we want?
    </aside>
    <p>Making an unit test</p>
    <pre><code>
  var mybirthday = new Date(1989, 0, 25);
  mybirthday.strftime('%m');  //"01"
  mybirthday.strftime('%F');  //"1989-01-25"

</pre></code>
  </section>

  <section>
    <aside class="notes"></aside>

    <pre><code>Date.prototype.strftime = (function () {
  function strftime(format) {
    var date = this;

    return (format + "").replace(/%([a-zA-Z])/g, function (m, f) {
      var formatter = Date.formats && Date.formats[f];

        //single formatter ('%d')
      if (typeof formatter == "function") {
        return formatter.call(Date.formats, date);

        //format shorthands ('%Y-%m-%d')
      } else if (typeof formatter == "string") {
        return date.strftime(formatter);
      }

      return f;
    });
  }

  // Internal helper
  function zeroPad(num) {
    return (+num < 10 ? "0" : "") + num;
  }

  Date.formats = {
    // Formatting methods
    d: function (date) {
      return zeroPad(date.getDate());
    },

    m: function (date) {
      return zeroPad(date.getMonth() + 1);
    },

    y: function (date) {
      return zeroPad(date.getYear() % 100);
    },

    Y: function (date) {
      return date.getFullYear();
    },

    // Format shorthands
    F: "%Y-%m-%d",
    D: "%m/%d/%y"
  };

  return strftime;
}());</code></pre>
  </section>

</section>
				<section>
  <aside class="notes">
    Ask people what do we need to test here?
    Without getting very detail oriented, first and foremost
    we need to check the output is giving us what we need</aside>
  <h3>How do we test this method?</h3>
  <ul>
    <li>What is our assumed state?</li>
    <li>What do we expect our output to be based on our assumed state?</li>    
  </ul>


</section>
				<section>
    <h3>Without automated testing:</h3>
    <pre><code>var date = new Date(1989, 0, 25);
    console.log('%Y:' + date.strftime('%Y'));
    console.log('%m:' + date.strftime('%m'));
    console.log('%d:' + date.strftime('%d'));
    console.log('%y:' + date.strftime('%y'));
    console.log('%F:' + date.strftime('%F'));</pre></code>
  <pre><code>    %Y:1989
    %m:1
    %d:25
    %y:89
    %F:1989-1-25</pre></code>
</section>
				<section>
  <h2>This is okay... but not great</h2>
  <ul>
    <li class="smaller red">Not repeatable</li>
    <li class="smaller red">Manual process</li>
    <li class="smaller red">Error detection via introspection</li>
  </ul>

  <p></br>How can we make this automatic?</p>
  <p class="smaller cyan">HTML test page!</p>
  <aside class="notes">
    Writing tests like this is not quantifiable.</br>
    Okay, so to make this more automatic, lets stop writing
    directly into the console. Let's write some code that
    we can deploy, in a repeatable way, from an html
    test page.

  </aside>
</section>
				<section>
  <section>
  <img src="../assets/strftime_js.png">
  <img src="../assets/strftime_test_html.png">
  </section>
  
  <section>
    <img src="../assets/console_output.png">
  </section>
  <aside class="notes">
    This is cool.. but there are obvious ways to make this better.</br>


  </aside>
</section>
				<section>
  <h3>This is better... but still not great</h3>
  <ul>
    <li class="smaller green">Repeatable</li>
    <li class="smaller green">Automatic process</li>
    <li class="smaller red">Error detection via introspection</li>
  </ul>

  <p></br>How can we make it more obvious when a bug has occured?</p>
  <p class="smaller cyan">Assertions!</p>
  <aside class="notes">
    Writing tests like this is not quantifiable.</br>
    Okay, so to make this more automatic, lets stop writing
    directly into the console. Let's write some code that
    we can deploy, in a repeatable way, from an html
    test page.

  </aside>
</section>
				<section>
  <h2>Assertions</h2>
  <aside class="notes">
    Assertions are the heart of testing.</br>
    Remember the earlier slide?
  </aside>
  <p class="orange">
    What do we expect the outcome to be</br>
    based on our assumed state?
  </p></br>

  <div class="fragment cyan">
    <p class="smaller">"I expect, assuming date=Jan 25 1989, date.strfttime(%d) to return 25"</p>
    <p class="smaller">"I expect the button to turn blue when I click it"</p>
  </div>
</section>
				<section class="relative">
    <h2>Assert Functions</h2>
      <pre><code>function assert(message, expr) {
    if (!expr) {
      throw new Error(message);
    }
    return true;
  }</pre></code>

    <div class="slide-9">
        <pre class="fragment"><code>assert("5 + 5 should equal 10", 5 + 5 === 10)</pre></code>
        <pre class="fragment"><code>assert("%Y should return full year",
               date.strftime("%Y") === "1989");</code></pre>
    </div>

    <aside class="notes">

    </aside>


</section>
				<section class="relative">
  <p class="left-align zero ">strtime_test.js</p>
  <pre><code class="height-50">var date = new Date(1989, 0, 25);
  try{
    assert("%Y should return full year",
           date.strftime("%Y") === "1989");

    assert("%m should return month",
          date.strftime("%m") === "01");

    assert("%d should return date",
           date.strftime("%d") === "25");

    assert("%y should return year as two digits",
        date.strftime("%y") === "89");

    assert("%F should be shortcut for %Y-%m-%d",
           date.strftime("%F") === "%Y-%m-%d");

  }catch(e){
    console.log("Test failed:" + e.message)
  }</pre></code>

<div class="slide-10">
  <pre>
    <code>function assert(message, expr) {
    if (!expr) {
      throw new Error(message);
    }
    return true;</code>
  </pre>
</div>


</section>
				<section>
  <p>But...</p>
  <img src="../assets/assert_fail_01.png">
  <p>...what about the rest of the tests?</p>

  <aside class="notes">
    This gets us a step closer to having automatic, repeatable tests.</br>
    But this does not give us the full picture of feedback.</br>
    Did just this test fail? Did the others pass?
</aside>
</section>
				<section>
  <p>Test Case: Set of related test functions</p>

  <pre><code>testCaseFunction([
    {assertion1},
    {assertion2},
    {assertion3},
    ...
    ])</pre></code>

</section>
				<section>
  <aside class="notes">
    <ul>
      <li>So we will construct a test case (suite of tests) to aggregate our
      unit tests.</li>
      <li>Note here the testCase function accepts a string param
      and an object param. The object param has property-value pairs. </li>
      <li>The property is a description of the test and the value is a function</li>
      <li>This allows us to loop through the object param and call each
      function.</li>
      <li>Side note here: this highlights in a small way the power
      of being able to pass functions around in js. Think about what
      would be necessary to call highly individualized functions for each
      test.</li>
      <li>Okay, so what does such a testCase function look like?</li>
    </ul>
  </aside>


  <p>Or something like this..</p>
  <pre><code class=" zero smaller height-50">var date = new Date(1989, 0, 25);

  testCase("strftime test", {

    "test format specifier %Y": function () {
        assert("%Y should return full year",
               Date.formats.Y(date) === "1989");
      },

      "test format specifier %m": function () {
        assert("%m should return month",
               Date.formats.m(date) === "01");
      },

      "test format specifier %d": function () {
        assert("%d should return date",
               Date.formats.d(date) === "25");
      },

      "test format specifier %y": function () {
        assert("%y should return year as two digits",
               Date.formats.y(date) === "89");
      },

      "test format shorthand %F": function () {
        assert("%F should be shortcut for %Y-%m-%d",
               Date.formats.F === "%Y-%m-%d");
      }
  }</pre></code>
</section>
				<section class="relative">
  <aside class="notes">
    <ul>
    <li>There are several important things going on in this code

    <li>This <code>testCase function</code> is going to loop
    through each property on the object (key value pair).</li>

    <li>The value here is the <code>assert</code> function that will tell
    us if our test is truthy.</li>

    <li>See here that the property value being returned here is a function,
    and this function is immediately being called.</li>

    <li>If it is TRUTHY, it will increment the successful counter
      and output a message using the nifty <code>output function</code> to our html test page</li>

    <li>If it is NOT truthy, it will catch the error.</br>
      AND also will: </br>
      output the message</br>
      NOT increment the successful counter</br>
      and--most importantly-- continue testing!</li>
    <ul>
  </aside>

 <h2>testCase function</h2>

 <pre><code class="zero">function testCase(testname, tests) {
    output("<h1>" + testname + "</h1>");
    var successful = 0;
    var testCount = 0;</code><code class="fragment" data-fragment-index="2">
    for (var test in tests) {
       testCount++;
       try {
         tests[test]();
         output(test, "#0c0");
         successful++;

       } catch (e) {
         output(test + " failed: " + e.message, "#c00");
       }
     }</code><code class="fragment" data-fragment-index="4">     var color = successful == testCount ? "#0c0" : "#c00";

     output("<strong>" + testCount + " tests, " +
            (testCount - successful) + " failures</strong>",
            color);
}</code></pre>

  <div class="box s-13 fragment" data-fragment-index="3"></div>

  <div class="slide-13" data-fragment-index="1">
     <pre>
       <code class="fragment" data-fragment-index="1">function output(text, color) {
         var p = document.createElement("p");
         p.innerHTML = text;
         p.style.color = color;
         document.body.appendChild(p);
       }</code>
     </pre>

     <img class="fragment" src="../assets/strftime_test_html_13.png">
   </div>


</section>
				<section class="relative">
  <p>Complete test_case.js</p>
    <pre><code class="zero smaller height-50">function testCase(name, tests) {
        assert.count = 0;
        var successful = 0;
        var testCount = 0;
        var hasSetup = typeof tests.setUp == "function";
        var hasTeardown = typeof tests.tearDown == "function";

        //If first word !=="test" skip to next
        for (var test in tests) {
          if (!/^test/.test(test)) {
            continue;
          }

          testCount++;

          try {
            if (hasSetup) {
              tests.setUp();
            }

            tests[test]();
            output(test, "#0c0");

            if (hasTeardown) {
              tests.tearDown();
            }

            successful++;
          } catch (e) {
            output(test + " failed: " + e.message, "#c00");
          }
        }

        var color = successful == testCount ? "#0c0" : "#c00";

        output("<strong>" + testCount + " tests, " +
               (testCount - successful) + " failures</strong>",
               color);
      }</code></pre>
    <div class="fragment slide-16">
      <img src="../assets/strfftime_test_js.png" alt="" />
    </div>

    <aside class="notes">
      Now the creation of the object belongs to the testCase
      method. This will be important later for "mocking".
    </aside>
</section>
				<section>
  <h3>Benefits of unit testing</h3>
  <ul class="light-blue">
    <li>Catching bugs during refactoring</li>
    <li>Cross browser testing</li>
    <li>Tests are self-documenting</li>
    <li>Shorter feedback loops</li>
  </ul>

  <aside class="notes">
      <ol>
        <li>Without having tests before  you refactor..
          there is nothing to ensure you didn't break something!</li>
        <li>Visually inspecting browsers sucks. Running a tests
          across our supported browsers could immediately tell us where a big lies</li>
        <li>Tests serve as </li>
        <li>You can quickly understand the point of the code thru tests</li>
        <li>Writing tests forces you to use methods you are testing--
        giving you a better understanding of what you're doing and leads
        likely will prompt you to write cleaner interfaces</li>
      </ol>
  </aside>
</section>
				<section>
  <aside class="notes">
    <ul>
      <li>TDD starts with tests</li>
      <li>Make a new object, function, etc.</li>
      <li>Write the tests for them, watch them fail (bc nothing exists yet!).</li>
      <li>Fill in with code, watch tests pass.</li>
    </ul>

    <ul>
      <li>BDD doesn't start with tests</li>
      <li>BDD doesn't necessarily test everything in an application</li>
    </ul>

    <ul>
      <li>Both should test small units.</li>
    </ul>

    <ul>
      <h4>EXAMPLE: writing a calculator</h4>
      <li>test addition of positive numbers</li>
      <li>test addition of neg numbers</li>
    </ul>

    <ul>
      <li>TDD IMO is better.</li>
      <li>Forces you to think before about logic only, NOT implementation.</li>
      <li>Guaruntees there are always tests &amp; better code coverage</li>
    </ul>
  </aside>


  <p class="larger gray">
    <span class="orange">Test Driven Development (TDD)</br></span>
    vs</br>
    <span class="light-blue">Behavior Driven Development (BDD)</span>
  </p>
</section>
				<section class="center-lists">
  <h3 class="zero light-blue">Unit Test Frameworks</h3>
    <ul class="smaller">
      <li>Mocha</li>
      <li>Qunit</li>
      <li>Jasmine</li>
      <li>Jest (for react)</li>
    </ul>

  <h3 class="zero light-blue">Assertion Libraries</h3>
  <ul class="smaller">
    <li>chai.js</li>
    <li>assert.js</li>
    <li>should.js</li>
    <li>YUI Port</li>
  </ul>

  <aside class="notes">
    <ul>
      <li>Unit Test Framework -- </br>
        is like the code from previous sections, but
        much more thourogh and with more capabilities
      </li>
      <li>Assertion libraries -- </br>
        fancy assert functions</li>
    </ul>
  </aside>
</section>
				<section>
  <h3>Q-Unit</h3>

  <pre><code>assert.equal( value, "hello", "We expect value to be hello" );
  assert.ok( 1 == "1", "Passed!" );
  assert.deepEqual( obj, { foo: "bar" }, "Two objects can be the same in value" );</code></pre>

  <img class="width-smaller" src="../assets/qunit.png">

</section>
				
<section>
  <h3>JASMINE</h3>


  -tests are refered to as specs
</section>
				<section>
  examples of mocha assertion frameworks
</section>
				<section>
  setting things up with mocha
  - getting source code

vocab
  -get index.html from distribution (test runner)
  -code actually being tested (system under test)
  -test file itself (file with assertions)

  quint
  -multiple test runners & tests (true for all?)
  -in quint the test runners === suites
</section>
				<section>
  <img src="../assets/johansenBook.png">
</section>
				<section>
  <img src="../assets/johansenBook.png">
</section>
				<section>
  <img src="../assets/johansenBook.png">
</section>
				<section>
  <img src="../assets/johansenBook.png">
</section>
				<section>
  <img src="../assets/johansenBook.png">
</section>
				



<!-- TBD ORDER -->
<section class="center-lists">
  <h3 class="zero light-blue">Test Runners</h3>
  <ul class="smaller">
    <li>Karma</li>
    <li>Wallaby</li>
  </ul>

  <h3 class="zero light-blue">Mocking Frameworks</h3>
  <ul class="smaller">
    <li>sinon</li>
    <li>assert.js</li>
  </ul>

  <h3 class="zero light-blue">Headless Browsers</h3>
  <ul class="smaller">
    <li>Web browser without GUI</li>
    <li>phantom.js</li>
    <li>jsdom</li>
  </ul>

</section>
				<!-- build:include ../slides/slide-30.html --><!-- /build -->
				<!-- build:include ../slides/slide-31.html --><!-- /build -->
				<!-- build:include ../slides/slide-32.html --><!-- /build -->
				<!-- build:include ../slides/slide-33.html --><!-- /build -->

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				slideNumber: true,
				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
